// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v6.33.4
// source: transport/internet/tls/config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../../typeRegistry";
import { SocketConfig } from "../config";

export const protobufPackage = "xray.transport.internet.tls";

export interface Certificate {
  $type: "xray.transport.internet.tls.Certificate";
  /** TLS certificate in x509 format. */
  certificate: Uint8Array;
  /** TLS key in x509 format. */
  key: Uint8Array;
  usage: Certificate_Usage;
  ocspStapling: number;
  /** TLS certificate path */
  certificatePath: string;
  /** TLS Key path */
  keyPath: string;
  /** If true, one-Time Loading */
  OneTimeLoading: boolean;
  buildChain: boolean;
}

export enum Certificate_Usage {
  ENCIPHERMENT = 0,
  AUTHORITY_VERIFY = 1,
  AUTHORITY_ISSUE = 2,
  UNRECOGNIZED = -1,
}

export function certificate_UsageFromJSON(object: any): Certificate_Usage {
  switch (object) {
    case 0:
    case "ENCIPHERMENT":
      return Certificate_Usage.ENCIPHERMENT;
    case 1:
    case "AUTHORITY_VERIFY":
      return Certificate_Usage.AUTHORITY_VERIFY;
    case 2:
    case "AUTHORITY_ISSUE":
      return Certificate_Usage.AUTHORITY_ISSUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Certificate_Usage.UNRECOGNIZED;
  }
}

export function certificate_UsageToJSON(object: Certificate_Usage): string {
  switch (object) {
    case Certificate_Usage.ENCIPHERMENT:
      return "ENCIPHERMENT";
    case Certificate_Usage.AUTHORITY_VERIFY:
      return "AUTHORITY_VERIFY";
    case Certificate_Usage.AUTHORITY_ISSUE:
      return "AUTHORITY_ISSUE";
    case Certificate_Usage.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Config {
  $type: "xray.transport.internet.tls.Config";
  allowInsecure: boolean;
  /** List of certificates to be served on server. */
  certificate: Certificate[];
  /** Override server name. */
  serverName: string;
  /** Lists of string as ALPN values. */
  nextProtocol: string[];
  /** Whether or not to enable session (ticket) resumption. */
  enableSessionResumption: boolean;
  /**
   * If true, root certificates on the system will not be loaded for
   * verification.
   */
  disableSystemRoot: boolean;
  /** The minimum TLS version. */
  minVersion: string;
  /** The maximum TLS version. */
  maxVersion: string;
  /** Specify cipher suites, except for TLS 1.3. */
  cipherSuites: string;
  /** TLS Client Hello fingerprint (uTLS). */
  fingerprint: string;
  rejectUnknownSni: boolean;
  masterKeyLog: string;
  /** Lists of string as CurvePreferences values. */
  curvePreferences: string[];
  verifyPeerCertByName: string[];
  echServerKeys: Uint8Array;
  echConfigList: string;
  echForceQuery: string;
  echSocketSettings: SocketConfig | undefined;
  pinnedPeerCertSha256: Uint8Array[];
}

function createBaseCertificate(): Certificate {
  return {
    $type: "xray.transport.internet.tls.Certificate",
    certificate: new Uint8Array(0),
    key: new Uint8Array(0),
    usage: 0,
    ocspStapling: 0,
    certificatePath: "",
    keyPath: "",
    OneTimeLoading: false,
    buildChain: false,
  };
}

export const Certificate: MessageFns<Certificate, "xray.transport.internet.tls.Certificate"> = {
  $type: "xray.transport.internet.tls.Certificate" as const,

  encode(message: Certificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.certificate.length !== 0) {
      writer.uint32(10).bytes(message.certificate);
    }
    if (message.key.length !== 0) {
      writer.uint32(18).bytes(message.key);
    }
    if (message.usage !== 0) {
      writer.uint32(24).int32(message.usage);
    }
    if (message.ocspStapling !== 0) {
      writer.uint32(32).uint64(message.ocspStapling);
    }
    if (message.certificatePath !== "") {
      writer.uint32(42).string(message.certificatePath);
    }
    if (message.keyPath !== "") {
      writer.uint32(50).string(message.keyPath);
    }
    if (message.OneTimeLoading !== false) {
      writer.uint32(56).bool(message.OneTimeLoading);
    }
    if (message.buildChain !== false) {
      writer.uint32(64).bool(message.buildChain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.certificate = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.usage = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ocspStapling = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.certificatePath = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.keyPath = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.OneTimeLoading = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.buildChain = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate {
    return {
      $type: Certificate.$type,
      certificate: isSet(object.certificate) ? bytesFromBase64(object.certificate) : new Uint8Array(0),
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      usage: isSet(object.usage) ? certificate_UsageFromJSON(object.usage) : 0,
      ocspStapling: isSet(object.ocspStapling)
        ? globalThis.Number(object.ocspStapling)
        : isSet(object.ocsp_stapling)
        ? globalThis.Number(object.ocsp_stapling)
        : 0,
      certificatePath: isSet(object.certificatePath)
        ? globalThis.String(object.certificatePath)
        : isSet(object.certificate_path)
        ? globalThis.String(object.certificate_path)
        : "",
      keyPath: isSet(object.keyPath)
        ? globalThis.String(object.keyPath)
        : isSet(object.key_path)
        ? globalThis.String(object.key_path)
        : "",
      OneTimeLoading: isSet(object.OneTimeLoading)
        ? globalThis.Boolean(object.OneTimeLoading)
        : isSet(object.One_time_loading)
        ? globalThis.Boolean(object.One_time_loading)
        : false,
      buildChain: isSet(object.buildChain)
        ? globalThis.Boolean(object.buildChain)
        : isSet(object.build_chain)
        ? globalThis.Boolean(object.build_chain)
        : false,
    };
  },

  toJSON(message: Certificate): unknown {
    const obj: any = {};
    if (message.certificate.length !== 0) {
      obj.certificate = base64FromBytes(message.certificate);
    }
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.usage !== 0) {
      obj.usage = certificate_UsageToJSON(message.usage);
    }
    if (message.ocspStapling !== 0) {
      obj.ocspStapling = Math.round(message.ocspStapling);
    }
    if (message.certificatePath !== "") {
      obj.certificatePath = message.certificatePath;
    }
    if (message.keyPath !== "") {
      obj.keyPath = message.keyPath;
    }
    if (message.OneTimeLoading !== false) {
      obj.OneTimeLoading = message.OneTimeLoading;
    }
    if (message.buildChain !== false) {
      obj.buildChain = message.buildChain;
    }
    return obj;
  },

  create(base?: DeepPartial<Certificate>): Certificate {
    return Certificate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Certificate>): Certificate {
    const message = createBaseCertificate();
    message.certificate = object.certificate ?? new Uint8Array(0);
    message.key = object.key ?? new Uint8Array(0);
    message.usage = object.usage ?? 0;
    message.ocspStapling = object.ocspStapling ?? 0;
    message.certificatePath = object.certificatePath ?? "";
    message.keyPath = object.keyPath ?? "";
    message.OneTimeLoading = object.OneTimeLoading ?? false;
    message.buildChain = object.buildChain ?? false;
    return message;
  },
};

messageTypeRegistry.set(Certificate.$type, Certificate);

function createBaseConfig(): Config {
  return {
    $type: "xray.transport.internet.tls.Config",
    allowInsecure: false,
    certificate: [],
    serverName: "",
    nextProtocol: [],
    enableSessionResumption: false,
    disableSystemRoot: false,
    minVersion: "",
    maxVersion: "",
    cipherSuites: "",
    fingerprint: "",
    rejectUnknownSni: false,
    masterKeyLog: "",
    curvePreferences: [],
    verifyPeerCertByName: [],
    echServerKeys: new Uint8Array(0),
    echConfigList: "",
    echForceQuery: "",
    echSocketSettings: undefined,
    pinnedPeerCertSha256: [],
  };
}

export const Config: MessageFns<Config, "xray.transport.internet.tls.Config"> = {
  $type: "xray.transport.internet.tls.Config" as const,

  encode(message: Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowInsecure !== false) {
      writer.uint32(8).bool(message.allowInsecure);
    }
    for (const v of message.certificate) {
      Certificate.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.serverName !== "") {
      writer.uint32(26).string(message.serverName);
    }
    for (const v of message.nextProtocol) {
      writer.uint32(34).string(v!);
    }
    if (message.enableSessionResumption !== false) {
      writer.uint32(40).bool(message.enableSessionResumption);
    }
    if (message.disableSystemRoot !== false) {
      writer.uint32(48).bool(message.disableSystemRoot);
    }
    if (message.minVersion !== "") {
      writer.uint32(58).string(message.minVersion);
    }
    if (message.maxVersion !== "") {
      writer.uint32(66).string(message.maxVersion);
    }
    if (message.cipherSuites !== "") {
      writer.uint32(74).string(message.cipherSuites);
    }
    if (message.fingerprint !== "") {
      writer.uint32(90).string(message.fingerprint);
    }
    if (message.rejectUnknownSni !== false) {
      writer.uint32(96).bool(message.rejectUnknownSni);
    }
    if (message.masterKeyLog !== "") {
      writer.uint32(122).string(message.masterKeyLog);
    }
    for (const v of message.curvePreferences) {
      writer.uint32(130).string(v!);
    }
    for (const v of message.verifyPeerCertByName) {
      writer.uint32(138).string(v!);
    }
    if (message.echServerKeys.length !== 0) {
      writer.uint32(146).bytes(message.echServerKeys);
    }
    if (message.echConfigList !== "") {
      writer.uint32(154).string(message.echConfigList);
    }
    if (message.echForceQuery !== "") {
      writer.uint32(162).string(message.echForceQuery);
    }
    if (message.echSocketSettings !== undefined) {
      SocketConfig.encode(message.echSocketSettings, writer.uint32(170).fork()).join();
    }
    for (const v of message.pinnedPeerCertSha256) {
      writer.uint32(178).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.allowInsecure = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.certificate.push(Certificate.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serverName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nextProtocol.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.enableSessionResumption = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.disableSystemRoot = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.minVersion = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.maxVersion = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.cipherSuites = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.fingerprint = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.rejectUnknownSni = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.masterKeyLog = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.curvePreferences.push(reader.string());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.verifyPeerCertByName.push(reader.string());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.echServerKeys = reader.bytes();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.echConfigList = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.echForceQuery = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.echSocketSettings = SocketConfig.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.pinnedPeerCertSha256.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Config {
    return {
      $type: Config.$type,
      allowInsecure: isSet(object.allowInsecure)
        ? globalThis.Boolean(object.allowInsecure)
        : isSet(object.allow_insecure)
        ? globalThis.Boolean(object.allow_insecure)
        : false,
      certificate: globalThis.Array.isArray(object?.certificate)
        ? object.certificate.map((e: any) => Certificate.fromJSON(e))
        : [],
      serverName: isSet(object.serverName)
        ? globalThis.String(object.serverName)
        : isSet(object.server_name)
        ? globalThis.String(object.server_name)
        : "",
      nextProtocol: globalThis.Array.isArray(object?.nextProtocol)
        ? object.nextProtocol.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.next_protocol)
        ? object.next_protocol.map((e: any) => globalThis.String(e))
        : [],
      enableSessionResumption: isSet(object.enableSessionResumption)
        ? globalThis.Boolean(object.enableSessionResumption)
        : isSet(object.enable_session_resumption)
        ? globalThis.Boolean(object.enable_session_resumption)
        : false,
      disableSystemRoot: isSet(object.disableSystemRoot)
        ? globalThis.Boolean(object.disableSystemRoot)
        : isSet(object.disable_system_root)
        ? globalThis.Boolean(object.disable_system_root)
        : false,
      minVersion: isSet(object.minVersion)
        ? globalThis.String(object.minVersion)
        : isSet(object.min_version)
        ? globalThis.String(object.min_version)
        : "",
      maxVersion: isSet(object.maxVersion)
        ? globalThis.String(object.maxVersion)
        : isSet(object.max_version)
        ? globalThis.String(object.max_version)
        : "",
      cipherSuites: isSet(object.cipherSuites)
        ? globalThis.String(object.cipherSuites)
        : isSet(object.cipher_suites)
        ? globalThis.String(object.cipher_suites)
        : "",
      fingerprint: isSet(object.fingerprint) ? globalThis.String(object.fingerprint) : "",
      rejectUnknownSni: isSet(object.rejectUnknownSni)
        ? globalThis.Boolean(object.rejectUnknownSni)
        : isSet(object.reject_unknown_sni)
        ? globalThis.Boolean(object.reject_unknown_sni)
        : false,
      masterKeyLog: isSet(object.masterKeyLog)
        ? globalThis.String(object.masterKeyLog)
        : isSet(object.master_key_log)
        ? globalThis.String(object.master_key_log)
        : "",
      curvePreferences: globalThis.Array.isArray(object?.curvePreferences)
        ? object.curvePreferences.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.curve_preferences)
        ? object.curve_preferences.map((e: any) => globalThis.String(e))
        : [],
      verifyPeerCertByName: globalThis.Array.isArray(object?.verifyPeerCertByName)
        ? object.verifyPeerCertByName.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.verify_peer_cert_by_name)
        ? object.verify_peer_cert_by_name.map((e: any) => globalThis.String(e))
        : [],
      echServerKeys: isSet(object.echServerKeys)
        ? bytesFromBase64(object.echServerKeys)
        : isSet(object.ech_server_keys)
        ? bytesFromBase64(object.ech_server_keys)
        : new Uint8Array(0),
      echConfigList: isSet(object.echConfigList)
        ? globalThis.String(object.echConfigList)
        : isSet(object.ech_config_list)
        ? globalThis.String(object.ech_config_list)
        : "",
      echForceQuery: isSet(object.echForceQuery)
        ? globalThis.String(object.echForceQuery)
        : isSet(object.ech_force_query)
        ? globalThis.String(object.ech_force_query)
        : "",
      echSocketSettings: isSet(object.echSocketSettings)
        ? SocketConfig.fromJSON(object.echSocketSettings)
        : isSet(object.ech_socket_settings)
        ? SocketConfig.fromJSON(object.ech_socket_settings)
        : undefined,
      pinnedPeerCertSha256: globalThis.Array.isArray(object?.pinnedPeerCertSha256)
        ? object.pinnedPeerCertSha256.map((e: any) => bytesFromBase64(e))
        : globalThis.Array.isArray(object?.pinned_peer_cert_sha256)
        ? object.pinned_peer_cert_sha256.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: Config): unknown {
    const obj: any = {};
    if (message.allowInsecure !== false) {
      obj.allowInsecure = message.allowInsecure;
    }
    if (message.certificate?.length) {
      obj.certificate = message.certificate.map((e) => Certificate.toJSON(e));
    }
    if (message.serverName !== "") {
      obj.serverName = message.serverName;
    }
    if (message.nextProtocol?.length) {
      obj.nextProtocol = message.nextProtocol;
    }
    if (message.enableSessionResumption !== false) {
      obj.enableSessionResumption = message.enableSessionResumption;
    }
    if (message.disableSystemRoot !== false) {
      obj.disableSystemRoot = message.disableSystemRoot;
    }
    if (message.minVersion !== "") {
      obj.minVersion = message.minVersion;
    }
    if (message.maxVersion !== "") {
      obj.maxVersion = message.maxVersion;
    }
    if (message.cipherSuites !== "") {
      obj.cipherSuites = message.cipherSuites;
    }
    if (message.fingerprint !== "") {
      obj.fingerprint = message.fingerprint;
    }
    if (message.rejectUnknownSni !== false) {
      obj.rejectUnknownSni = message.rejectUnknownSni;
    }
    if (message.masterKeyLog !== "") {
      obj.masterKeyLog = message.masterKeyLog;
    }
    if (message.curvePreferences?.length) {
      obj.curvePreferences = message.curvePreferences;
    }
    if (message.verifyPeerCertByName?.length) {
      obj.verifyPeerCertByName = message.verifyPeerCertByName;
    }
    if (message.echServerKeys.length !== 0) {
      obj.echServerKeys = base64FromBytes(message.echServerKeys);
    }
    if (message.echConfigList !== "") {
      obj.echConfigList = message.echConfigList;
    }
    if (message.echForceQuery !== "") {
      obj.echForceQuery = message.echForceQuery;
    }
    if (message.echSocketSettings !== undefined) {
      obj.echSocketSettings = SocketConfig.toJSON(message.echSocketSettings);
    }
    if (message.pinnedPeerCertSha256?.length) {
      obj.pinnedPeerCertSha256 = message.pinnedPeerCertSha256.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Config>): Config {
    return Config.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Config>): Config {
    const message = createBaseConfig();
    message.allowInsecure = object.allowInsecure ?? false;
    message.certificate = object.certificate?.map((e) => Certificate.fromPartial(e)) || [];
    message.serverName = object.serverName ?? "";
    message.nextProtocol = object.nextProtocol?.map((e) => e) || [];
    message.enableSessionResumption = object.enableSessionResumption ?? false;
    message.disableSystemRoot = object.disableSystemRoot ?? false;
    message.minVersion = object.minVersion ?? "";
    message.maxVersion = object.maxVersion ?? "";
    message.cipherSuites = object.cipherSuites ?? "";
    message.fingerprint = object.fingerprint ?? "";
    message.rejectUnknownSni = object.rejectUnknownSni ?? false;
    message.masterKeyLog = object.masterKeyLog ?? "";
    message.curvePreferences = object.curvePreferences?.map((e) => e) || [];
    message.verifyPeerCertByName = object.verifyPeerCertByName?.map((e) => e) || [];
    message.echServerKeys = object.echServerKeys ?? new Uint8Array(0);
    message.echConfigList = object.echConfigList ?? "";
    message.echForceQuery = object.echForceQuery ?? "";
    message.echSocketSettings = (object.echSocketSettings !== undefined && object.echSocketSettings !== null)
      ? SocketConfig.fromPartial(object.echSocketSettings)
      : undefined;
    message.pinnedPeerCertSha256 = object.pinnedPeerCertSha256?.map((e) => e) || [];
    return message;
  },
};

messageTypeRegistry.set(Config.$type, Config);

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               v5.28.3
// source: app/proxyman/config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { IPOrDomain } from "../../common/net/address";
import { PortList } from "../../common/net/port";
import { TypedMessage } from "../../common/serial/typed_message";
import { ProxyConfig, StreamConfig } from "../../transport/internet/config";
import { messageTypeRegistry } from "../../typeRegistry";

export const protobufPackage = "xray.app.proxyman";

export enum KnownProtocols {
  HTTP = 0,
  TLS = 1,
  UNRECOGNIZED = -1,
}

export function knownProtocolsFromJSON(object: any): KnownProtocols {
  switch (object) {
    case 0:
    case "HTTP":
      return KnownProtocols.HTTP;
    case 1:
    case "TLS":
      return KnownProtocols.TLS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KnownProtocols.UNRECOGNIZED;
  }
}

export function knownProtocolsToJSON(object: KnownProtocols): string {
  switch (object) {
    case KnownProtocols.HTTP:
      return "HTTP";
    case KnownProtocols.TLS:
      return "TLS";
    case KnownProtocols.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface InboundConfig {
  $type: "xray.app.proxyman.InboundConfig";
}

export interface AllocationStrategy {
  $type: "xray.app.proxyman.AllocationStrategy";
  type: AllocationStrategy_Type;
  /**
   * Number of handlers (ports) running in parallel.
   * Default value is 3 if unset.
   */
  concurrency:
    | AllocationStrategy_AllocationStrategyConcurrency
    | undefined;
  /**
   * Number of minutes before a handler is regenerated.
   * Default value is 5 if unset.
   */
  refresh: AllocationStrategy_AllocationStrategyRefresh | undefined;
}

export enum AllocationStrategy_Type {
  /** Always - Always allocate all connection handlers. */
  Always = 0,
  /** Random - Randomly allocate specific range of handlers. */
  Random = 1,
  /** External - External. Not supported yet. */
  External = 2,
  UNRECOGNIZED = -1,
}

export function allocationStrategy_TypeFromJSON(object: any): AllocationStrategy_Type {
  switch (object) {
    case 0:
    case "Always":
      return AllocationStrategy_Type.Always;
    case 1:
    case "Random":
      return AllocationStrategy_Type.Random;
    case 2:
    case "External":
      return AllocationStrategy_Type.External;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AllocationStrategy_Type.UNRECOGNIZED;
  }
}

export function allocationStrategy_TypeToJSON(object: AllocationStrategy_Type): string {
  switch (object) {
    case AllocationStrategy_Type.Always:
      return "Always";
    case AllocationStrategy_Type.Random:
      return "Random";
    case AllocationStrategy_Type.External:
      return "External";
    case AllocationStrategy_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AllocationStrategy_AllocationStrategyConcurrency {
  $type: "xray.app.proxyman.AllocationStrategy.AllocationStrategyConcurrency";
  value: number;
}

export interface AllocationStrategy_AllocationStrategyRefresh {
  $type: "xray.app.proxyman.AllocationStrategy.AllocationStrategyRefresh";
  value: number;
}

export interface SniffingConfig {
  $type: "xray.app.proxyman.SniffingConfig";
  /** Whether or not to enable content sniffing on an inbound connection. */
  enabled: boolean;
  /**
   * Override target destination if sniff'ed protocol is in the given list.
   * Supported values are "http", "tls", "fakedns".
   */
  destinationOverride: string[];
  domainsExcluded: string[];
  /**
   * Whether should only try to sniff metadata without waiting for client input.
   * Can be used to support SMTP like protocol where server send the first
   * message.
   */
  metadataOnly: boolean;
  routeOnly: boolean;
}

export interface ReceiverConfig {
  $type: "xray.app.proxyman.ReceiverConfig";
  /** PortList specifies the ports which the Receiver should listen on. */
  portList:
    | PortList
    | undefined;
  /** Listen specifies the IP address that the Receiver should listen on. */
  listen: IPOrDomain | undefined;
  allocationStrategy: AllocationStrategy | undefined;
  streamSettings: StreamConfig | undefined;
  receiveOriginalDestination: boolean;
  /**
   * Override domains for the given protocol.
   * Deprecated. Use sniffing_settings.
   *
   * @deprecated
   */
  domainOverride: KnownProtocols[];
  sniffingSettings: SniffingConfig | undefined;
}

export interface InboundHandlerConfig {
  $type: "xray.app.proxyman.InboundHandlerConfig";
  tag: string;
  receiverSettings: TypedMessage | undefined;
  proxySettings: TypedMessage | undefined;
}

export interface OutboundConfig {
  $type: "xray.app.proxyman.OutboundConfig";
}

export interface SenderConfig {
  $type: "xray.app.proxyman.SenderConfig";
  /** Send traffic through the given IP. Only IP is allowed. */
  via: IPOrDomain | undefined;
  streamSettings: StreamConfig | undefined;
  proxySettings: ProxyConfig | undefined;
  multiplexSettings: MultiplexingConfig | undefined;
}

export interface MultiplexingConfig {
  $type: "xray.app.proxyman.MultiplexingConfig";
  /** Whether or not Mux is enabled. */
  enabled: boolean;
  /** Max number of concurrent connections that one Mux connection can handle. */
  concurrency: number;
  /** Transport XUDP in another Mux. */
  xudpConcurrency: number;
  /** "reject" (default), "allow" or "skip". */
  xudpProxyUDP443: string;
}

function createBaseInboundConfig(): InboundConfig {
  return { $type: "xray.app.proxyman.InboundConfig" };
}

export const InboundConfig: MessageFns<InboundConfig, "xray.app.proxyman.InboundConfig"> = {
  $type: "xray.app.proxyman.InboundConfig" as const,

  encode(_: InboundConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InboundConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInboundConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InboundConfig {
    return { $type: InboundConfig.$type };
  },

  toJSON(_: InboundConfig): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<InboundConfig>): InboundConfig {
    return InboundConfig.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<InboundConfig>): InboundConfig {
    const message = createBaseInboundConfig();
    return message;
  },
};

messageTypeRegistry.set(InboundConfig.$type, InboundConfig);

function createBaseAllocationStrategy(): AllocationStrategy {
  return { $type: "xray.app.proxyman.AllocationStrategy", type: 0, concurrency: undefined, refresh: undefined };
}

export const AllocationStrategy: MessageFns<AllocationStrategy, "xray.app.proxyman.AllocationStrategy"> = {
  $type: "xray.app.proxyman.AllocationStrategy" as const,

  encode(message: AllocationStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.concurrency !== undefined) {
      AllocationStrategy_AllocationStrategyConcurrency.encode(message.concurrency, writer.uint32(18).fork()).join();
    }
    if (message.refresh !== undefined) {
      AllocationStrategy_AllocationStrategyRefresh.encode(message.refresh, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllocationStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllocationStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.concurrency = AllocationStrategy_AllocationStrategyConcurrency.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refresh = AllocationStrategy_AllocationStrategyRefresh.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllocationStrategy {
    return {
      $type: AllocationStrategy.$type,
      type: isSet(object.type) ? allocationStrategy_TypeFromJSON(object.type) : 0,
      concurrency: isSet(object.concurrency)
        ? AllocationStrategy_AllocationStrategyConcurrency.fromJSON(object.concurrency)
        : undefined,
      refresh: isSet(object.refresh)
        ? AllocationStrategy_AllocationStrategyRefresh.fromJSON(object.refresh)
        : undefined,
    };
  },

  toJSON(message: AllocationStrategy): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = allocationStrategy_TypeToJSON(message.type);
    }
    if (message.concurrency !== undefined) {
      obj.concurrency = AllocationStrategy_AllocationStrategyConcurrency.toJSON(message.concurrency);
    }
    if (message.refresh !== undefined) {
      obj.refresh = AllocationStrategy_AllocationStrategyRefresh.toJSON(message.refresh);
    }
    return obj;
  },

  create(base?: DeepPartial<AllocationStrategy>): AllocationStrategy {
    return AllocationStrategy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AllocationStrategy>): AllocationStrategy {
    const message = createBaseAllocationStrategy();
    message.type = object.type ?? 0;
    message.concurrency = (object.concurrency !== undefined && object.concurrency !== null)
      ? AllocationStrategy_AllocationStrategyConcurrency.fromPartial(object.concurrency)
      : undefined;
    message.refresh = (object.refresh !== undefined && object.refresh !== null)
      ? AllocationStrategy_AllocationStrategyRefresh.fromPartial(object.refresh)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(AllocationStrategy.$type, AllocationStrategy);

function createBaseAllocationStrategy_AllocationStrategyConcurrency(): AllocationStrategy_AllocationStrategyConcurrency {
  return { $type: "xray.app.proxyman.AllocationStrategy.AllocationStrategyConcurrency", value: 0 };
}

export const AllocationStrategy_AllocationStrategyConcurrency: MessageFns<
  AllocationStrategy_AllocationStrategyConcurrency,
  "xray.app.proxyman.AllocationStrategy.AllocationStrategyConcurrency"
> = {
  $type: "xray.app.proxyman.AllocationStrategy.AllocationStrategyConcurrency" as const,

  encode(
    message: AllocationStrategy_AllocationStrategyConcurrency,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).uint32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllocationStrategy_AllocationStrategyConcurrency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllocationStrategy_AllocationStrategyConcurrency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllocationStrategy_AllocationStrategyConcurrency {
    return {
      $type: AllocationStrategy_AllocationStrategyConcurrency.$type,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: AllocationStrategy_AllocationStrategyConcurrency): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AllocationStrategy_AllocationStrategyConcurrency>,
  ): AllocationStrategy_AllocationStrategyConcurrency {
    return AllocationStrategy_AllocationStrategyConcurrency.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AllocationStrategy_AllocationStrategyConcurrency>,
  ): AllocationStrategy_AllocationStrategyConcurrency {
    const message = createBaseAllocationStrategy_AllocationStrategyConcurrency();
    message.value = object.value ?? 0;
    return message;
  },
};

messageTypeRegistry.set(
  AllocationStrategy_AllocationStrategyConcurrency.$type,
  AllocationStrategy_AllocationStrategyConcurrency,
);

function createBaseAllocationStrategy_AllocationStrategyRefresh(): AllocationStrategy_AllocationStrategyRefresh {
  return { $type: "xray.app.proxyman.AllocationStrategy.AllocationStrategyRefresh", value: 0 };
}

export const AllocationStrategy_AllocationStrategyRefresh: MessageFns<
  AllocationStrategy_AllocationStrategyRefresh,
  "xray.app.proxyman.AllocationStrategy.AllocationStrategyRefresh"
> = {
  $type: "xray.app.proxyman.AllocationStrategy.AllocationStrategyRefresh" as const,

  encode(
    message: AllocationStrategy_AllocationStrategyRefresh,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).uint32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllocationStrategy_AllocationStrategyRefresh {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllocationStrategy_AllocationStrategyRefresh();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllocationStrategy_AllocationStrategyRefresh {
    return {
      $type: AllocationStrategy_AllocationStrategyRefresh.$type,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: AllocationStrategy_AllocationStrategyRefresh): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AllocationStrategy_AllocationStrategyRefresh>,
  ): AllocationStrategy_AllocationStrategyRefresh {
    return AllocationStrategy_AllocationStrategyRefresh.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AllocationStrategy_AllocationStrategyRefresh>,
  ): AllocationStrategy_AllocationStrategyRefresh {
    const message = createBaseAllocationStrategy_AllocationStrategyRefresh();
    message.value = object.value ?? 0;
    return message;
  },
};

messageTypeRegistry.set(
  AllocationStrategy_AllocationStrategyRefresh.$type,
  AllocationStrategy_AllocationStrategyRefresh,
);

function createBaseSniffingConfig(): SniffingConfig {
  return {
    $type: "xray.app.proxyman.SniffingConfig",
    enabled: false,
    destinationOverride: [],
    domainsExcluded: [],
    metadataOnly: false,
    routeOnly: false,
  };
}

export const SniffingConfig: MessageFns<SniffingConfig, "xray.app.proxyman.SniffingConfig"> = {
  $type: "xray.app.proxyman.SniffingConfig" as const,

  encode(message: SniffingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    for (const v of message.destinationOverride) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.domainsExcluded) {
      writer.uint32(26).string(v!);
    }
    if (message.metadataOnly !== false) {
      writer.uint32(32).bool(message.metadataOnly);
    }
    if (message.routeOnly !== false) {
      writer.uint32(40).bool(message.routeOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SniffingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSniffingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destinationOverride.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.domainsExcluded.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.metadataOnly = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.routeOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SniffingConfig {
    return {
      $type: SniffingConfig.$type,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      destinationOverride: globalThis.Array.isArray(object?.destinationOverride)
        ? object.destinationOverride.map((e: any) => globalThis.String(e))
        : [],
      domainsExcluded: globalThis.Array.isArray(object?.domainsExcluded)
        ? object.domainsExcluded.map((e: any) => globalThis.String(e))
        : [],
      metadataOnly: isSet(object.metadataOnly) ? globalThis.Boolean(object.metadataOnly) : false,
      routeOnly: isSet(object.routeOnly) ? globalThis.Boolean(object.routeOnly) : false,
    };
  },

  toJSON(message: SniffingConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.destinationOverride?.length) {
      obj.destinationOverride = message.destinationOverride;
    }
    if (message.domainsExcluded?.length) {
      obj.domainsExcluded = message.domainsExcluded;
    }
    if (message.metadataOnly !== false) {
      obj.metadataOnly = message.metadataOnly;
    }
    if (message.routeOnly !== false) {
      obj.routeOnly = message.routeOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<SniffingConfig>): SniffingConfig {
    return SniffingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SniffingConfig>): SniffingConfig {
    const message = createBaseSniffingConfig();
    message.enabled = object.enabled ?? false;
    message.destinationOverride = object.destinationOverride?.map((e) => e) || [];
    message.domainsExcluded = object.domainsExcluded?.map((e) => e) || [];
    message.metadataOnly = object.metadataOnly ?? false;
    message.routeOnly = object.routeOnly ?? false;
    return message;
  },
};

messageTypeRegistry.set(SniffingConfig.$type, SniffingConfig);

function createBaseReceiverConfig(): ReceiverConfig {
  return {
    $type: "xray.app.proxyman.ReceiverConfig",
    portList: undefined,
    listen: undefined,
    allocationStrategy: undefined,
    streamSettings: undefined,
    receiveOriginalDestination: false,
    domainOverride: [],
    sniffingSettings: undefined,
  };
}

export const ReceiverConfig: MessageFns<ReceiverConfig, "xray.app.proxyman.ReceiverConfig"> = {
  $type: "xray.app.proxyman.ReceiverConfig" as const,

  encode(message: ReceiverConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.portList !== undefined) {
      PortList.encode(message.portList, writer.uint32(10).fork()).join();
    }
    if (message.listen !== undefined) {
      IPOrDomain.encode(message.listen, writer.uint32(18).fork()).join();
    }
    if (message.allocationStrategy !== undefined) {
      AllocationStrategy.encode(message.allocationStrategy, writer.uint32(26).fork()).join();
    }
    if (message.streamSettings !== undefined) {
      StreamConfig.encode(message.streamSettings, writer.uint32(34).fork()).join();
    }
    if (message.receiveOriginalDestination !== false) {
      writer.uint32(40).bool(message.receiveOriginalDestination);
    }
    writer.uint32(58).fork();
    for (const v of message.domainOverride) {
      writer.int32(v);
    }
    writer.join();
    if (message.sniffingSettings !== undefined) {
      SniffingConfig.encode(message.sniffingSettings, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiverConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiverConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.portList = PortList.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.listen = IPOrDomain.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.allocationStrategy = AllocationStrategy.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.streamSettings = StreamConfig.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.receiveOriginalDestination = reader.bool();
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.domainOverride.push(reader.int32() as any);

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.domainOverride.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sniffingSettings = SniffingConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiverConfig {
    return {
      $type: ReceiverConfig.$type,
      portList: isSet(object.portList) ? PortList.fromJSON(object.portList) : undefined,
      listen: isSet(object.listen) ? IPOrDomain.fromJSON(object.listen) : undefined,
      allocationStrategy: isSet(object.allocationStrategy)
        ? AllocationStrategy.fromJSON(object.allocationStrategy)
        : undefined,
      streamSettings: isSet(object.streamSettings) ? StreamConfig.fromJSON(object.streamSettings) : undefined,
      receiveOriginalDestination: isSet(object.receiveOriginalDestination)
        ? globalThis.Boolean(object.receiveOriginalDestination)
        : false,
      domainOverride: globalThis.Array.isArray(object?.domainOverride)
        ? object.domainOverride.map((e: any) => knownProtocolsFromJSON(e))
        : [],
      sniffingSettings: isSet(object.sniffingSettings) ? SniffingConfig.fromJSON(object.sniffingSettings) : undefined,
    };
  },

  toJSON(message: ReceiverConfig): unknown {
    const obj: any = {};
    if (message.portList !== undefined) {
      obj.portList = PortList.toJSON(message.portList);
    }
    if (message.listen !== undefined) {
      obj.listen = IPOrDomain.toJSON(message.listen);
    }
    if (message.allocationStrategy !== undefined) {
      obj.allocationStrategy = AllocationStrategy.toJSON(message.allocationStrategy);
    }
    if (message.streamSettings !== undefined) {
      obj.streamSettings = StreamConfig.toJSON(message.streamSettings);
    }
    if (message.receiveOriginalDestination !== false) {
      obj.receiveOriginalDestination = message.receiveOriginalDestination;
    }
    if (message.domainOverride?.length) {
      obj.domainOverride = message.domainOverride.map((e) => knownProtocolsToJSON(e));
    }
    if (message.sniffingSettings !== undefined) {
      obj.sniffingSettings = SniffingConfig.toJSON(message.sniffingSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<ReceiverConfig>): ReceiverConfig {
    return ReceiverConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReceiverConfig>): ReceiverConfig {
    const message = createBaseReceiverConfig();
    message.portList = (object.portList !== undefined && object.portList !== null)
      ? PortList.fromPartial(object.portList)
      : undefined;
    message.listen = (object.listen !== undefined && object.listen !== null)
      ? IPOrDomain.fromPartial(object.listen)
      : undefined;
    message.allocationStrategy = (object.allocationStrategy !== undefined && object.allocationStrategy !== null)
      ? AllocationStrategy.fromPartial(object.allocationStrategy)
      : undefined;
    message.streamSettings = (object.streamSettings !== undefined && object.streamSettings !== null)
      ? StreamConfig.fromPartial(object.streamSettings)
      : undefined;
    message.receiveOriginalDestination = object.receiveOriginalDestination ?? false;
    message.domainOverride = object.domainOverride?.map((e) => e) || [];
    message.sniffingSettings = (object.sniffingSettings !== undefined && object.sniffingSettings !== null)
      ? SniffingConfig.fromPartial(object.sniffingSettings)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(ReceiverConfig.$type, ReceiverConfig);

function createBaseInboundHandlerConfig(): InboundHandlerConfig {
  return {
    $type: "xray.app.proxyman.InboundHandlerConfig",
    tag: "",
    receiverSettings: undefined,
    proxySettings: undefined,
  };
}

export const InboundHandlerConfig: MessageFns<InboundHandlerConfig, "xray.app.proxyman.InboundHandlerConfig"> = {
  $type: "xray.app.proxyman.InboundHandlerConfig" as const,

  encode(message: InboundHandlerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    if (message.receiverSettings !== undefined) {
      TypedMessage.encode(message.receiverSettings, writer.uint32(18).fork()).join();
    }
    if (message.proxySettings !== undefined) {
      TypedMessage.encode(message.proxySettings, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InboundHandlerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInboundHandlerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receiverSettings = TypedMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proxySettings = TypedMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InboundHandlerConfig {
    return {
      $type: InboundHandlerConfig.$type,
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      receiverSettings: isSet(object.receiverSettings) ? TypedMessage.fromJSON(object.receiverSettings) : undefined,
      proxySettings: isSet(object.proxySettings) ? TypedMessage.fromJSON(object.proxySettings) : undefined,
    };
  },

  toJSON(message: InboundHandlerConfig): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.receiverSettings !== undefined) {
      obj.receiverSettings = TypedMessage.toJSON(message.receiverSettings);
    }
    if (message.proxySettings !== undefined) {
      obj.proxySettings = TypedMessage.toJSON(message.proxySettings);
    }
    return obj;
  },

  create(base?: DeepPartial<InboundHandlerConfig>): InboundHandlerConfig {
    return InboundHandlerConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InboundHandlerConfig>): InboundHandlerConfig {
    const message = createBaseInboundHandlerConfig();
    message.tag = object.tag ?? "";
    message.receiverSettings = (object.receiverSettings !== undefined && object.receiverSettings !== null)
      ? TypedMessage.fromPartial(object.receiverSettings)
      : undefined;
    message.proxySettings = (object.proxySettings !== undefined && object.proxySettings !== null)
      ? TypedMessage.fromPartial(object.proxySettings)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(InboundHandlerConfig.$type, InboundHandlerConfig);

function createBaseOutboundConfig(): OutboundConfig {
  return { $type: "xray.app.proxyman.OutboundConfig" };
}

export const OutboundConfig: MessageFns<OutboundConfig, "xray.app.proxyman.OutboundConfig"> = {
  $type: "xray.app.proxyman.OutboundConfig" as const,

  encode(_: OutboundConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutboundConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutboundConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): OutboundConfig {
    return { $type: OutboundConfig.$type };
  },

  toJSON(_: OutboundConfig): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<OutboundConfig>): OutboundConfig {
    return OutboundConfig.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<OutboundConfig>): OutboundConfig {
    const message = createBaseOutboundConfig();
    return message;
  },
};

messageTypeRegistry.set(OutboundConfig.$type, OutboundConfig);

function createBaseSenderConfig(): SenderConfig {
  return {
    $type: "xray.app.proxyman.SenderConfig",
    via: undefined,
    streamSettings: undefined,
    proxySettings: undefined,
    multiplexSettings: undefined,
  };
}

export const SenderConfig: MessageFns<SenderConfig, "xray.app.proxyman.SenderConfig"> = {
  $type: "xray.app.proxyman.SenderConfig" as const,

  encode(message: SenderConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.via !== undefined) {
      IPOrDomain.encode(message.via, writer.uint32(10).fork()).join();
    }
    if (message.streamSettings !== undefined) {
      StreamConfig.encode(message.streamSettings, writer.uint32(18).fork()).join();
    }
    if (message.proxySettings !== undefined) {
      ProxyConfig.encode(message.proxySettings, writer.uint32(26).fork()).join();
    }
    if (message.multiplexSettings !== undefined) {
      MultiplexingConfig.encode(message.multiplexSettings, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SenderConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSenderConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.via = IPOrDomain.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.streamSettings = StreamConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proxySettings = ProxyConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.multiplexSettings = MultiplexingConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SenderConfig {
    return {
      $type: SenderConfig.$type,
      via: isSet(object.via) ? IPOrDomain.fromJSON(object.via) : undefined,
      streamSettings: isSet(object.streamSettings) ? StreamConfig.fromJSON(object.streamSettings) : undefined,
      proxySettings: isSet(object.proxySettings) ? ProxyConfig.fromJSON(object.proxySettings) : undefined,
      multiplexSettings: isSet(object.multiplexSettings)
        ? MultiplexingConfig.fromJSON(object.multiplexSettings)
        : undefined,
    };
  },

  toJSON(message: SenderConfig): unknown {
    const obj: any = {};
    if (message.via !== undefined) {
      obj.via = IPOrDomain.toJSON(message.via);
    }
    if (message.streamSettings !== undefined) {
      obj.streamSettings = StreamConfig.toJSON(message.streamSettings);
    }
    if (message.proxySettings !== undefined) {
      obj.proxySettings = ProxyConfig.toJSON(message.proxySettings);
    }
    if (message.multiplexSettings !== undefined) {
      obj.multiplexSettings = MultiplexingConfig.toJSON(message.multiplexSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<SenderConfig>): SenderConfig {
    return SenderConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SenderConfig>): SenderConfig {
    const message = createBaseSenderConfig();
    message.via = (object.via !== undefined && object.via !== null) ? IPOrDomain.fromPartial(object.via) : undefined;
    message.streamSettings = (object.streamSettings !== undefined && object.streamSettings !== null)
      ? StreamConfig.fromPartial(object.streamSettings)
      : undefined;
    message.proxySettings = (object.proxySettings !== undefined && object.proxySettings !== null)
      ? ProxyConfig.fromPartial(object.proxySettings)
      : undefined;
    message.multiplexSettings = (object.multiplexSettings !== undefined && object.multiplexSettings !== null)
      ? MultiplexingConfig.fromPartial(object.multiplexSettings)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(SenderConfig.$type, SenderConfig);

function createBaseMultiplexingConfig(): MultiplexingConfig {
  return {
    $type: "xray.app.proxyman.MultiplexingConfig",
    enabled: false,
    concurrency: 0,
    xudpConcurrency: 0,
    xudpProxyUDP443: "",
  };
}

export const MultiplexingConfig: MessageFns<MultiplexingConfig, "xray.app.proxyman.MultiplexingConfig"> = {
  $type: "xray.app.proxyman.MultiplexingConfig" as const,

  encode(message: MultiplexingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.concurrency !== 0) {
      writer.uint32(16).int32(message.concurrency);
    }
    if (message.xudpConcurrency !== 0) {
      writer.uint32(24).int32(message.xudpConcurrency);
    }
    if (message.xudpProxyUDP443 !== "") {
      writer.uint32(34).string(message.xudpProxyUDP443);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiplexingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiplexingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.concurrency = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.xudpConcurrency = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.xudpProxyUDP443 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiplexingConfig {
    return {
      $type: MultiplexingConfig.$type,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      concurrency: isSet(object.concurrency) ? globalThis.Number(object.concurrency) : 0,
      xudpConcurrency: isSet(object.xudpConcurrency) ? globalThis.Number(object.xudpConcurrency) : 0,
      xudpProxyUDP443: isSet(object.xudpProxyUDP443) ? globalThis.String(object.xudpProxyUDP443) : "",
    };
  },

  toJSON(message: MultiplexingConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.concurrency !== 0) {
      obj.concurrency = Math.round(message.concurrency);
    }
    if (message.xudpConcurrency !== 0) {
      obj.xudpConcurrency = Math.round(message.xudpConcurrency);
    }
    if (message.xudpProxyUDP443 !== "") {
      obj.xudpProxyUDP443 = message.xudpProxyUDP443;
    }
    return obj;
  },

  create(base?: DeepPartial<MultiplexingConfig>): MultiplexingConfig {
    return MultiplexingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MultiplexingConfig>): MultiplexingConfig {
    const message = createBaseMultiplexingConfig();
    message.enabled = object.enabled ?? false;
    message.concurrency = object.concurrency ?? 0;
    message.xudpConcurrency = object.xudpConcurrency ?? 0;
    message.xudpProxyUDP443 = object.xudpProxyUDP443 ?? "";
    return message;
  },
};

messageTypeRegistry.set(MultiplexingConfig.$type, MultiplexingConfig);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}

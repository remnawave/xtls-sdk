// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               v5.28.3
// source: app/router/config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Network, networkFromJSON, NetworkList, networkToJSON } from "../../common/net/network";
import { PortList, PortRange } from "../../common/net/port";
import { messageTypeRegistry } from "../../typeRegistry";

export const protobufPackage = "xray.app.router";

/** Domain for routing decision. */
export interface Domain {
  $type: "xray.app.router.Domain";
  /** Domain matching type. */
  type: Domain_Type;
  /** Domain value. */
  value: string;
  /** Attributes of this domain. May be used for filtering. */
  attribute: Domain_Attribute[];
}

/** Type of domain value. */
export enum Domain_Type {
  /** Plain - The value is used as is. */
  Plain = 0,
  /** Regex - The value is used as a regular expression. */
  Regex = 1,
  /** Domain - The value is a root domain. */
  Domain = 2,
  /** Full - The value is a domain. */
  Full = 3,
  UNRECOGNIZED = -1,
}

export function domain_TypeFromJSON(object: any): Domain_Type {
  switch (object) {
    case 0:
    case "Plain":
      return Domain_Type.Plain;
    case 1:
    case "Regex":
      return Domain_Type.Regex;
    case 2:
    case "Domain":
      return Domain_Type.Domain;
    case 3:
    case "Full":
      return Domain_Type.Full;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Domain_Type.UNRECOGNIZED;
  }
}

export function domain_TypeToJSON(object: Domain_Type): string {
  switch (object) {
    case Domain_Type.Plain:
      return "Plain";
    case Domain_Type.Regex:
      return "Regex";
    case Domain_Type.Domain:
      return "Domain";
    case Domain_Type.Full:
      return "Full";
    case Domain_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Domain_Attribute {
  $type: "xray.app.router.Domain.Attribute";
  key: string;
  boolValue?: boolean | undefined;
  intValue?: number | undefined;
}

/** IP for routing decision, in CIDR form. */
export interface CIDR {
  $type: "xray.app.router.CIDR";
  /** IP address, should be either 4 or 16 bytes. */
  ip: Uint8Array;
  /** Number of leading ones in the network mask. */
  prefix: number;
}

export interface GeoIP {
  $type: "xray.app.router.GeoIP";
  countryCode: string;
  cidr: CIDR[];
  reverseMatch: boolean;
}

export interface GeoIPList {
  $type: "xray.app.router.GeoIPList";
  entry: GeoIP[];
}

export interface GeoSite {
  $type: "xray.app.router.GeoSite";
  countryCode: string;
  domain: Domain[];
}

export interface GeoSiteList {
  $type: "xray.app.router.GeoSiteList";
  entry: GeoSite[];
}

export interface RoutingRule {
  $type: "xray.app.router.RoutingRule";
  /** Tag of outbound that this rule is pointing to. */
  tag?:
    | string
    | undefined;
  /** Tag of routing balancer. */
  balancingTag?:
    | string
    | undefined;
  /** List of domains for target domain matching. */
  domain: Domain[];
  /**
   * List of CIDRs for target IP address matching.
   * Deprecated. Use geoip below.
   *
   * @deprecated
   */
  cidr: CIDR[];
  /**
   * List of GeoIPs for target IP address matching. If this entry exists, the
   * cidr above will have no effect. GeoIP fields with the same country code are
   * supposed to contain exactly same content. They will be merged during
   * runtime. For customized GeoIPs, please leave country code empty.
   */
  geoip: GeoIP[];
  /**
   * A range of port [from, to]. If the destination port is in this range, this
   * rule takes effect. Deprecated. Use port_list.
   *
   * @deprecated
   */
  portRange:
    | PortRange
    | undefined;
  /** List of ports. */
  portList:
    | PortList
    | undefined;
  /**
   * List of networks. Deprecated. Use networks.
   *
   * @deprecated
   */
  networkList:
    | NetworkList
    | undefined;
  /** List of networks for matching. */
  networks: Network[];
  /**
   * List of CIDRs for source IP address matching.
   *
   * @deprecated
   */
  sourceCidr: CIDR[];
  /**
   * List of GeoIPs for source IP address matching. If this entry exists, the
   * source_cidr above will have no effect.
   */
  sourceGeoip: GeoIP[];
  /** List of ports for source port matching. */
  sourcePortList: PortList | undefined;
  userEmail: string[];
  inboundTag: string[];
  protocol: string[];
  attributes: { [key: string]: string };
  domainMatcher: string;
}

export interface RoutingRule_AttributesEntry {
  $type: "xray.app.router.RoutingRule.AttributesEntry";
  key: string;
  value: string;
}

export interface BalancingRule {
  $type: "xray.app.router.BalancingRule";
  tag: string;
  outboundSelector: string[];
  strategy: string;
}

export interface Config {
  $type: "xray.app.router.Config";
  domainStrategy: Config_DomainStrategy;
  rule: RoutingRule[];
  balancingRule: BalancingRule[];
}

export enum Config_DomainStrategy {
  /** AsIs - Use domain as is. */
  AsIs = 0,
  /** UseIp - Always resolve IP for domains. */
  UseIp = 1,
  /** IpIfNonMatch - Resolve to IP if the domain doesn't match any rules. */
  IpIfNonMatch = 2,
  /** IpOnDemand - Resolve to IP if any rule requires IP matching. */
  IpOnDemand = 3,
  UNRECOGNIZED = -1,
}

export function config_DomainStrategyFromJSON(object: any): Config_DomainStrategy {
  switch (object) {
    case 0:
    case "AsIs":
      return Config_DomainStrategy.AsIs;
    case 1:
    case "UseIp":
      return Config_DomainStrategy.UseIp;
    case 2:
    case "IpIfNonMatch":
      return Config_DomainStrategy.IpIfNonMatch;
    case 3:
    case "IpOnDemand":
      return Config_DomainStrategy.IpOnDemand;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Config_DomainStrategy.UNRECOGNIZED;
  }
}

export function config_DomainStrategyToJSON(object: Config_DomainStrategy): string {
  switch (object) {
    case Config_DomainStrategy.AsIs:
      return "AsIs";
    case Config_DomainStrategy.UseIp:
      return "UseIp";
    case Config_DomainStrategy.IpIfNonMatch:
      return "IpIfNonMatch";
    case Config_DomainStrategy.IpOnDemand:
      return "IpOnDemand";
    case Config_DomainStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseDomain(): Domain {
  return { $type: "xray.app.router.Domain", type: 0, value: "", attribute: [] };
}

export const Domain: MessageFns<Domain, "xray.app.router.Domain"> = {
  $type: "xray.app.router.Domain" as const,

  encode(message: Domain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    for (const v of message.attribute) {
      Domain_Attribute.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Domain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDomain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.attribute.push(Domain_Attribute.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Domain {
    return {
      $type: Domain.$type,
      type: isSet(object.type) ? domain_TypeFromJSON(object.type) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      attribute: globalThis.Array.isArray(object?.attribute)
        ? object.attribute.map((e: any) => Domain_Attribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Domain): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = domain_TypeToJSON(message.type);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.attribute?.length) {
      obj.attribute = message.attribute.map((e) => Domain_Attribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Domain>): Domain {
    return Domain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Domain>): Domain {
    const message = createBaseDomain();
    message.type = object.type ?? 0;
    message.value = object.value ?? "";
    message.attribute = object.attribute?.map((e) => Domain_Attribute.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(Domain.$type, Domain);

function createBaseDomain_Attribute(): Domain_Attribute {
  return { $type: "xray.app.router.Domain.Attribute", key: "", boolValue: undefined, intValue: undefined };
}

export const Domain_Attribute: MessageFns<Domain_Attribute, "xray.app.router.Domain.Attribute"> = {
  $type: "xray.app.router.Domain.Attribute" as const,

  encode(message: Domain_Attribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.boolValue !== undefined) {
      writer.uint32(16).bool(message.boolValue);
    }
    if (message.intValue !== undefined) {
      writer.uint32(24).int64(message.intValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Domain_Attribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDomain_Attribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.intValue = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Domain_Attribute {
    return {
      $type: Domain_Attribute.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      intValue: isSet(object.intValue) ? globalThis.Number(object.intValue) : undefined,
    };
  },

  toJSON(message: Domain_Attribute): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.intValue !== undefined) {
      obj.intValue = Math.round(message.intValue);
    }
    return obj;
  },

  create(base?: DeepPartial<Domain_Attribute>): Domain_Attribute {
    return Domain_Attribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Domain_Attribute>): Domain_Attribute {
    const message = createBaseDomain_Attribute();
    message.key = object.key ?? "";
    message.boolValue = object.boolValue ?? undefined;
    message.intValue = object.intValue ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Domain_Attribute.$type, Domain_Attribute);

function createBaseCIDR(): CIDR {
  return { $type: "xray.app.router.CIDR", ip: new Uint8Array(0), prefix: 0 };
}

export const CIDR: MessageFns<CIDR, "xray.app.router.CIDR"> = {
  $type: "xray.app.router.CIDR" as const,

  encode(message: CIDR, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ip.length !== 0) {
      writer.uint32(10).bytes(message.ip);
    }
    if (message.prefix !== 0) {
      writer.uint32(16).uint32(message.prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CIDR {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCIDR();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ip = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.prefix = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CIDR {
    return {
      $type: CIDR.$type,
      ip: isSet(object.ip) ? bytesFromBase64(object.ip) : new Uint8Array(0),
      prefix: isSet(object.prefix) ? globalThis.Number(object.prefix) : 0,
    };
  },

  toJSON(message: CIDR): unknown {
    const obj: any = {};
    if (message.ip.length !== 0) {
      obj.ip = base64FromBytes(message.ip);
    }
    if (message.prefix !== 0) {
      obj.prefix = Math.round(message.prefix);
    }
    return obj;
  },

  create(base?: DeepPartial<CIDR>): CIDR {
    return CIDR.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CIDR>): CIDR {
    const message = createBaseCIDR();
    message.ip = object.ip ?? new Uint8Array(0);
    message.prefix = object.prefix ?? 0;
    return message;
  },
};

messageTypeRegistry.set(CIDR.$type, CIDR);

function createBaseGeoIP(): GeoIP {
  return { $type: "xray.app.router.GeoIP", countryCode: "", cidr: [], reverseMatch: false };
}

export const GeoIP: MessageFns<GeoIP, "xray.app.router.GeoIP"> = {
  $type: "xray.app.router.GeoIP" as const,

  encode(message: GeoIP, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.countryCode !== "") {
      writer.uint32(10).string(message.countryCode);
    }
    for (const v of message.cidr) {
      CIDR.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.reverseMatch !== false) {
      writer.uint32(24).bool(message.reverseMatch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoIP {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoIP();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cidr.push(CIDR.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reverseMatch = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoIP {
    return {
      $type: GeoIP.$type,
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
      cidr: globalThis.Array.isArray(object?.cidr) ? object.cidr.map((e: any) => CIDR.fromJSON(e)) : [],
      reverseMatch: isSet(object.reverseMatch) ? globalThis.Boolean(object.reverseMatch) : false,
    };
  },

  toJSON(message: GeoIP): unknown {
    const obj: any = {};
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.cidr?.length) {
      obj.cidr = message.cidr.map((e) => CIDR.toJSON(e));
    }
    if (message.reverseMatch !== false) {
      obj.reverseMatch = message.reverseMatch;
    }
    return obj;
  },

  create(base?: DeepPartial<GeoIP>): GeoIP {
    return GeoIP.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GeoIP>): GeoIP {
    const message = createBaseGeoIP();
    message.countryCode = object.countryCode ?? "";
    message.cidr = object.cidr?.map((e) => CIDR.fromPartial(e)) || [];
    message.reverseMatch = object.reverseMatch ?? false;
    return message;
  },
};

messageTypeRegistry.set(GeoIP.$type, GeoIP);

function createBaseGeoIPList(): GeoIPList {
  return { $type: "xray.app.router.GeoIPList", entry: [] };
}

export const GeoIPList: MessageFns<GeoIPList, "xray.app.router.GeoIPList"> = {
  $type: "xray.app.router.GeoIPList" as const,

  encode(message: GeoIPList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entry) {
      GeoIP.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoIPList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoIPList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entry.push(GeoIP.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoIPList {
    return {
      $type: GeoIPList.$type,
      entry: globalThis.Array.isArray(object?.entry) ? object.entry.map((e: any) => GeoIP.fromJSON(e)) : [],
    };
  },

  toJSON(message: GeoIPList): unknown {
    const obj: any = {};
    if (message.entry?.length) {
      obj.entry = message.entry.map((e) => GeoIP.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GeoIPList>): GeoIPList {
    return GeoIPList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GeoIPList>): GeoIPList {
    const message = createBaseGeoIPList();
    message.entry = object.entry?.map((e) => GeoIP.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(GeoIPList.$type, GeoIPList);

function createBaseGeoSite(): GeoSite {
  return { $type: "xray.app.router.GeoSite", countryCode: "", domain: [] };
}

export const GeoSite: MessageFns<GeoSite, "xray.app.router.GeoSite"> = {
  $type: "xray.app.router.GeoSite" as const,

  encode(message: GeoSite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.countryCode !== "") {
      writer.uint32(10).string(message.countryCode);
    }
    for (const v of message.domain) {
      Domain.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoSite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoSite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.domain.push(Domain.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoSite {
    return {
      $type: GeoSite.$type,
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
      domain: globalThis.Array.isArray(object?.domain) ? object.domain.map((e: any) => Domain.fromJSON(e)) : [],
    };
  },

  toJSON(message: GeoSite): unknown {
    const obj: any = {};
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.domain?.length) {
      obj.domain = message.domain.map((e) => Domain.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GeoSite>): GeoSite {
    return GeoSite.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GeoSite>): GeoSite {
    const message = createBaseGeoSite();
    message.countryCode = object.countryCode ?? "";
    message.domain = object.domain?.map((e) => Domain.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(GeoSite.$type, GeoSite);

function createBaseGeoSiteList(): GeoSiteList {
  return { $type: "xray.app.router.GeoSiteList", entry: [] };
}

export const GeoSiteList: MessageFns<GeoSiteList, "xray.app.router.GeoSiteList"> = {
  $type: "xray.app.router.GeoSiteList" as const,

  encode(message: GeoSiteList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entry) {
      GeoSite.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoSiteList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoSiteList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entry.push(GeoSite.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoSiteList {
    return {
      $type: GeoSiteList.$type,
      entry: globalThis.Array.isArray(object?.entry) ? object.entry.map((e: any) => GeoSite.fromJSON(e)) : [],
    };
  },

  toJSON(message: GeoSiteList): unknown {
    const obj: any = {};
    if (message.entry?.length) {
      obj.entry = message.entry.map((e) => GeoSite.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GeoSiteList>): GeoSiteList {
    return GeoSiteList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GeoSiteList>): GeoSiteList {
    const message = createBaseGeoSiteList();
    message.entry = object.entry?.map((e) => GeoSite.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(GeoSiteList.$type, GeoSiteList);

function createBaseRoutingRule(): RoutingRule {
  return {
    $type: "xray.app.router.RoutingRule",
    tag: undefined,
    balancingTag: undefined,
    domain: [],
    cidr: [],
    geoip: [],
    portRange: undefined,
    portList: undefined,
    networkList: undefined,
    networks: [],
    sourceCidr: [],
    sourceGeoip: [],
    sourcePortList: undefined,
    userEmail: [],
    inboundTag: [],
    protocol: [],
    attributes: {},
    domainMatcher: "",
  };
}

export const RoutingRule: MessageFns<RoutingRule, "xray.app.router.RoutingRule"> = {
  $type: "xray.app.router.RoutingRule" as const,

  encode(message: RoutingRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== undefined) {
      writer.uint32(10).string(message.tag);
    }
    if (message.balancingTag !== undefined) {
      writer.uint32(98).string(message.balancingTag);
    }
    for (const v of message.domain) {
      Domain.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.cidr) {
      CIDR.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.geoip) {
      GeoIP.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.portRange !== undefined) {
      PortRange.encode(message.portRange, writer.uint32(34).fork()).join();
    }
    if (message.portList !== undefined) {
      PortList.encode(message.portList, writer.uint32(114).fork()).join();
    }
    if (message.networkList !== undefined) {
      NetworkList.encode(message.networkList, writer.uint32(42).fork()).join();
    }
    writer.uint32(106).fork();
    for (const v of message.networks) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.sourceCidr) {
      CIDR.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.sourceGeoip) {
      GeoIP.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.sourcePortList !== undefined) {
      PortList.encode(message.sourcePortList, writer.uint32(130).fork()).join();
    }
    for (const v of message.userEmail) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.inboundTag) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.protocol) {
      writer.uint32(74).string(v!);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      RoutingRule_AttributesEntry.encode({
        $type: "xray.app.router.RoutingRule.AttributesEntry",
        key: key as any,
        value,
      }, writer.uint32(122).fork()).join();
    });
    if (message.domainMatcher !== "") {
      writer.uint32(138).string(message.domainMatcher);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutingRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutingRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.balancingTag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.domain.push(Domain.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cidr.push(CIDR.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.geoip.push(GeoIP.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.portRange = PortRange.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.portList = PortList.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.networkList = NetworkList.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag === 104) {
            message.networks.push(reader.int32() as any);

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.networks.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sourceCidr.push(CIDR.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.sourceGeoip.push(GeoIP.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.sourcePortList = PortList.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.userEmail.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.inboundTag.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.protocol.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = RoutingRule_AttributesEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.attributes[entry15.key] = entry15.value;
          }
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.domainMatcher = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutingRule {
    return {
      $type: RoutingRule.$type,
      tag: isSet(object.tag) ? globalThis.String(object.tag) : undefined,
      balancingTag: isSet(object.balancingTag) ? globalThis.String(object.balancingTag) : undefined,
      domain: globalThis.Array.isArray(object?.domain) ? object.domain.map((e: any) => Domain.fromJSON(e)) : [],
      cidr: globalThis.Array.isArray(object?.cidr) ? object.cidr.map((e: any) => CIDR.fromJSON(e)) : [],
      geoip: globalThis.Array.isArray(object?.geoip) ? object.geoip.map((e: any) => GeoIP.fromJSON(e)) : [],
      portRange: isSet(object.portRange) ? PortRange.fromJSON(object.portRange) : undefined,
      portList: isSet(object.portList) ? PortList.fromJSON(object.portList) : undefined,
      networkList: isSet(object.networkList) ? NetworkList.fromJSON(object.networkList) : undefined,
      networks: globalThis.Array.isArray(object?.networks) ? object.networks.map((e: any) => networkFromJSON(e)) : [],
      sourceCidr: globalThis.Array.isArray(object?.sourceCidr)
        ? object.sourceCidr.map((e: any) => CIDR.fromJSON(e))
        : [],
      sourceGeoip: globalThis.Array.isArray(object?.sourceGeoip)
        ? object.sourceGeoip.map((e: any) => GeoIP.fromJSON(e))
        : [],
      sourcePortList: isSet(object.sourcePortList) ? PortList.fromJSON(object.sourcePortList) : undefined,
      userEmail: globalThis.Array.isArray(object?.userEmail)
        ? object.userEmail.map((e: any) => globalThis.String(e))
        : [],
      inboundTag: globalThis.Array.isArray(object?.inboundTag)
        ? object.inboundTag.map((e: any) => globalThis.String(e))
        : [],
      protocol: globalThis.Array.isArray(object?.protocol) ? object.protocol.map((e: any) => globalThis.String(e)) : [],
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      domainMatcher: isSet(object.domainMatcher) ? globalThis.String(object.domainMatcher) : "",
    };
  },

  toJSON(message: RoutingRule): unknown {
    const obj: any = {};
    if (message.tag !== undefined) {
      obj.tag = message.tag;
    }
    if (message.balancingTag !== undefined) {
      obj.balancingTag = message.balancingTag;
    }
    if (message.domain?.length) {
      obj.domain = message.domain.map((e) => Domain.toJSON(e));
    }
    if (message.cidr?.length) {
      obj.cidr = message.cidr.map((e) => CIDR.toJSON(e));
    }
    if (message.geoip?.length) {
      obj.geoip = message.geoip.map((e) => GeoIP.toJSON(e));
    }
    if (message.portRange !== undefined) {
      obj.portRange = PortRange.toJSON(message.portRange);
    }
    if (message.portList !== undefined) {
      obj.portList = PortList.toJSON(message.portList);
    }
    if (message.networkList !== undefined) {
      obj.networkList = NetworkList.toJSON(message.networkList);
    }
    if (message.networks?.length) {
      obj.networks = message.networks.map((e) => networkToJSON(e));
    }
    if (message.sourceCidr?.length) {
      obj.sourceCidr = message.sourceCidr.map((e) => CIDR.toJSON(e));
    }
    if (message.sourceGeoip?.length) {
      obj.sourceGeoip = message.sourceGeoip.map((e) => GeoIP.toJSON(e));
    }
    if (message.sourcePortList !== undefined) {
      obj.sourcePortList = PortList.toJSON(message.sourcePortList);
    }
    if (message.userEmail?.length) {
      obj.userEmail = message.userEmail;
    }
    if (message.inboundTag?.length) {
      obj.inboundTag = message.inboundTag;
    }
    if (message.protocol?.length) {
      obj.protocol = message.protocol;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    if (message.domainMatcher !== "") {
      obj.domainMatcher = message.domainMatcher;
    }
    return obj;
  },

  create(base?: DeepPartial<RoutingRule>): RoutingRule {
    return RoutingRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoutingRule>): RoutingRule {
    const message = createBaseRoutingRule();
    message.tag = object.tag ?? undefined;
    message.balancingTag = object.balancingTag ?? undefined;
    message.domain = object.domain?.map((e) => Domain.fromPartial(e)) || [];
    message.cidr = object.cidr?.map((e) => CIDR.fromPartial(e)) || [];
    message.geoip = object.geoip?.map((e) => GeoIP.fromPartial(e)) || [];
    message.portRange = (object.portRange !== undefined && object.portRange !== null)
      ? PortRange.fromPartial(object.portRange)
      : undefined;
    message.portList = (object.portList !== undefined && object.portList !== null)
      ? PortList.fromPartial(object.portList)
      : undefined;
    message.networkList = (object.networkList !== undefined && object.networkList !== null)
      ? NetworkList.fromPartial(object.networkList)
      : undefined;
    message.networks = object.networks?.map((e) => e) || [];
    message.sourceCidr = object.sourceCidr?.map((e) => CIDR.fromPartial(e)) || [];
    message.sourceGeoip = object.sourceGeoip?.map((e) => GeoIP.fromPartial(e)) || [];
    message.sourcePortList = (object.sourcePortList !== undefined && object.sourcePortList !== null)
      ? PortList.fromPartial(object.sourcePortList)
      : undefined;
    message.userEmail = object.userEmail?.map((e) => e) || [];
    message.inboundTag = object.inboundTag?.map((e) => e) || [];
    message.protocol = object.protocol?.map((e) => e) || [];
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.domainMatcher = object.domainMatcher ?? "";
    return message;
  },
};

messageTypeRegistry.set(RoutingRule.$type, RoutingRule);

function createBaseRoutingRule_AttributesEntry(): RoutingRule_AttributesEntry {
  return { $type: "xray.app.router.RoutingRule.AttributesEntry", key: "", value: "" };
}

export const RoutingRule_AttributesEntry: MessageFns<
  RoutingRule_AttributesEntry,
  "xray.app.router.RoutingRule.AttributesEntry"
> = {
  $type: "xray.app.router.RoutingRule.AttributesEntry" as const,

  encode(message: RoutingRule_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutingRule_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutingRule_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutingRule_AttributesEntry {
    return {
      $type: RoutingRule_AttributesEntry.$type,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RoutingRule_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<RoutingRule_AttributesEntry>): RoutingRule_AttributesEntry {
    return RoutingRule_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoutingRule_AttributesEntry>): RoutingRule_AttributesEntry {
    const message = createBaseRoutingRule_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

messageTypeRegistry.set(RoutingRule_AttributesEntry.$type, RoutingRule_AttributesEntry);

function createBaseBalancingRule(): BalancingRule {
  return { $type: "xray.app.router.BalancingRule", tag: "", outboundSelector: [], strategy: "" };
}

export const BalancingRule: MessageFns<BalancingRule, "xray.app.router.BalancingRule"> = {
  $type: "xray.app.router.BalancingRule" as const,

  encode(message: BalancingRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    for (const v of message.outboundSelector) {
      writer.uint32(18).string(v!);
    }
    if (message.strategy !== "") {
      writer.uint32(26).string(message.strategy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BalancingRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalancingRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outboundSelector.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.strategy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalancingRule {
    return {
      $type: BalancingRule.$type,
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      outboundSelector: globalThis.Array.isArray(object?.outboundSelector)
        ? object.outboundSelector.map((e: any) => globalThis.String(e))
        : [],
      strategy: isSet(object.strategy) ? globalThis.String(object.strategy) : "",
    };
  },

  toJSON(message: BalancingRule): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.outboundSelector?.length) {
      obj.outboundSelector = message.outboundSelector;
    }
    if (message.strategy !== "") {
      obj.strategy = message.strategy;
    }
    return obj;
  },

  create(base?: DeepPartial<BalancingRule>): BalancingRule {
    return BalancingRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BalancingRule>): BalancingRule {
    const message = createBaseBalancingRule();
    message.tag = object.tag ?? "";
    message.outboundSelector = object.outboundSelector?.map((e) => e) || [];
    message.strategy = object.strategy ?? "";
    return message;
  },
};

messageTypeRegistry.set(BalancingRule.$type, BalancingRule);

function createBaseConfig(): Config {
  return { $type: "xray.app.router.Config", domainStrategy: 0, rule: [], balancingRule: [] };
}

export const Config: MessageFns<Config, "xray.app.router.Config"> = {
  $type: "xray.app.router.Config" as const,

  encode(message: Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domainStrategy !== 0) {
      writer.uint32(8).int32(message.domainStrategy);
    }
    for (const v of message.rule) {
      RoutingRule.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.balancingRule) {
      BalancingRule.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.domainStrategy = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rule.push(RoutingRule.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.balancingRule.push(BalancingRule.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Config {
    return {
      $type: Config.$type,
      domainStrategy: isSet(object.domainStrategy) ? config_DomainStrategyFromJSON(object.domainStrategy) : 0,
      rule: globalThis.Array.isArray(object?.rule) ? object.rule.map((e: any) => RoutingRule.fromJSON(e)) : [],
      balancingRule: globalThis.Array.isArray(object?.balancingRule)
        ? object.balancingRule.map((e: any) => BalancingRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Config): unknown {
    const obj: any = {};
    if (message.domainStrategy !== 0) {
      obj.domainStrategy = config_DomainStrategyToJSON(message.domainStrategy);
    }
    if (message.rule?.length) {
      obj.rule = message.rule.map((e) => RoutingRule.toJSON(e));
    }
    if (message.balancingRule?.length) {
      obj.balancingRule = message.balancingRule.map((e) => BalancingRule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Config>): Config {
    return Config.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Config>): Config {
    const message = createBaseConfig();
    message.domainStrategy = object.domainStrategy ?? 0;
    message.rule = object.rule?.map((e) => RoutingRule.fromPartial(e)) || [];
    message.balancingRule = object.balancingRule?.map((e) => BalancingRule.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(Config.$type, Config);

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}

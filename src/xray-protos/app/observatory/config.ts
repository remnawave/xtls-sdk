// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               v5.28.3
// source: app/observatory/config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { messageTypeRegistry } from "../../typeRegistry";

export const protobufPackage = "xray.core.app.observatory";

export interface ObservationResult {
  $type: "xray.core.app.observatory.ObservationResult";
  status: OutboundStatus[];
}

export interface OutboundStatus {
  $type: "xray.core.app.observatory.OutboundStatus";
  /**
   * @Document Whether this outbound is usable
   * @Restriction ReadOnlyForUser
   */
  alive: boolean;
  /**
   * @Document The time for probe request to finish.
   * @Type time.ms
   * @Restriction ReadOnlyForUser
   */
  delay: number;
  /**
   * @Document The last error caused this outbound failed to relay probe request
   * @Restriction NotMachineReadable
   */
  lastErrorReason: string;
  /**
   * @Document The outbound tag for this Server
   * @Type id.outboundTag
   */
  outboundTag: string;
  /**
   * @Document The time this outbound is known to be alive
   * @Type id.outboundTag
   */
  lastSeenTime: number;
  /**
   * @Document The time this outbound is tried
   * @Type id.outboundTag
   */
  lastTryTime: number;
}

export interface ProbeResult {
  $type: "xray.core.app.observatory.ProbeResult";
  /**
   * @Document Whether this outbound is usable
   * @Restriction ReadOnlyForUser
   */
  alive: boolean;
  /**
   * @Document The time for probe request to finish.
   * @Type time.ms
   * @Restriction ReadOnlyForUser
   */
  delay: number;
  /**
   * @Document The error caused this outbound failed to relay probe request
   * @Restriction NotMachineReadable
   */
  lastErrorReason: string;
}

export interface Intensity {
  $type: "xray.core.app.observatory.Intensity";
  /**
   * @Document The time interval for a probe request in ms.
   * @Type time.ms
   */
  probeInterval: number;
}

export interface Config {
  $type: "xray.core.app.observatory.Config";
  /** @Document The selectors for outbound under observation */
  subjectSelector: string[];
  probeUrl: string;
  probeInterval: number;
  enableConcurrency: boolean;
}

function createBaseObservationResult(): ObservationResult {
  return { $type: "xray.core.app.observatory.ObservationResult", status: [] };
}

export const ObservationResult: MessageFns<ObservationResult, "xray.core.app.observatory.ObservationResult"> = {
  $type: "xray.core.app.observatory.ObservationResult" as const,

  encode(message: ObservationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.status) {
      OutboundStatus.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObservationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObservationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status.push(OutboundStatus.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObservationResult {
    return {
      $type: ObservationResult.$type,
      status: globalThis.Array.isArray(object?.status) ? object.status.map((e: any) => OutboundStatus.fromJSON(e)) : [],
    };
  },

  toJSON(message: ObservationResult): unknown {
    const obj: any = {};
    if (message.status?.length) {
      obj.status = message.status.map((e) => OutboundStatus.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ObservationResult>): ObservationResult {
    return ObservationResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObservationResult>): ObservationResult {
    const message = createBaseObservationResult();
    message.status = object.status?.map((e) => OutboundStatus.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(ObservationResult.$type, ObservationResult);

function createBaseOutboundStatus(): OutboundStatus {
  return {
    $type: "xray.core.app.observatory.OutboundStatus",
    alive: false,
    delay: 0,
    lastErrorReason: "",
    outboundTag: "",
    lastSeenTime: 0,
    lastTryTime: 0,
  };
}

export const OutboundStatus: MessageFns<OutboundStatus, "xray.core.app.observatory.OutboundStatus"> = {
  $type: "xray.core.app.observatory.OutboundStatus" as const,

  encode(message: OutboundStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.alive !== false) {
      writer.uint32(8).bool(message.alive);
    }
    if (message.delay !== 0) {
      writer.uint32(16).int64(message.delay);
    }
    if (message.lastErrorReason !== "") {
      writer.uint32(26).string(message.lastErrorReason);
    }
    if (message.outboundTag !== "") {
      writer.uint32(34).string(message.outboundTag);
    }
    if (message.lastSeenTime !== 0) {
      writer.uint32(40).int64(message.lastSeenTime);
    }
    if (message.lastTryTime !== 0) {
      writer.uint32(48).int64(message.lastTryTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutboundStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutboundStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.alive = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.delay = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastErrorReason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outboundTag = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lastSeenTime = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lastTryTime = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutboundStatus {
    return {
      $type: OutboundStatus.$type,
      alive: isSet(object.alive) ? globalThis.Boolean(object.alive) : false,
      delay: isSet(object.delay) ? globalThis.Number(object.delay) : 0,
      lastErrorReason: isSet(object.lastErrorReason) ? globalThis.String(object.lastErrorReason) : "",
      outboundTag: isSet(object.outboundTag) ? globalThis.String(object.outboundTag) : "",
      lastSeenTime: isSet(object.lastSeenTime) ? globalThis.Number(object.lastSeenTime) : 0,
      lastTryTime: isSet(object.lastTryTime) ? globalThis.Number(object.lastTryTime) : 0,
    };
  },

  toJSON(message: OutboundStatus): unknown {
    const obj: any = {};
    if (message.alive !== false) {
      obj.alive = message.alive;
    }
    if (message.delay !== 0) {
      obj.delay = Math.round(message.delay);
    }
    if (message.lastErrorReason !== "") {
      obj.lastErrorReason = message.lastErrorReason;
    }
    if (message.outboundTag !== "") {
      obj.outboundTag = message.outboundTag;
    }
    if (message.lastSeenTime !== 0) {
      obj.lastSeenTime = Math.round(message.lastSeenTime);
    }
    if (message.lastTryTime !== 0) {
      obj.lastTryTime = Math.round(message.lastTryTime);
    }
    return obj;
  },

  create(base?: DeepPartial<OutboundStatus>): OutboundStatus {
    return OutboundStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutboundStatus>): OutboundStatus {
    const message = createBaseOutboundStatus();
    message.alive = object.alive ?? false;
    message.delay = object.delay ?? 0;
    message.lastErrorReason = object.lastErrorReason ?? "";
    message.outboundTag = object.outboundTag ?? "";
    message.lastSeenTime = object.lastSeenTime ?? 0;
    message.lastTryTime = object.lastTryTime ?? 0;
    return message;
  },
};

messageTypeRegistry.set(OutboundStatus.$type, OutboundStatus);

function createBaseProbeResult(): ProbeResult {
  return { $type: "xray.core.app.observatory.ProbeResult", alive: false, delay: 0, lastErrorReason: "" };
}

export const ProbeResult: MessageFns<ProbeResult, "xray.core.app.observatory.ProbeResult"> = {
  $type: "xray.core.app.observatory.ProbeResult" as const,

  encode(message: ProbeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.alive !== false) {
      writer.uint32(8).bool(message.alive);
    }
    if (message.delay !== 0) {
      writer.uint32(16).int64(message.delay);
    }
    if (message.lastErrorReason !== "") {
      writer.uint32(26).string(message.lastErrorReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProbeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProbeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.alive = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.delay = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastErrorReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProbeResult {
    return {
      $type: ProbeResult.$type,
      alive: isSet(object.alive) ? globalThis.Boolean(object.alive) : false,
      delay: isSet(object.delay) ? globalThis.Number(object.delay) : 0,
      lastErrorReason: isSet(object.lastErrorReason) ? globalThis.String(object.lastErrorReason) : "",
    };
  },

  toJSON(message: ProbeResult): unknown {
    const obj: any = {};
    if (message.alive !== false) {
      obj.alive = message.alive;
    }
    if (message.delay !== 0) {
      obj.delay = Math.round(message.delay);
    }
    if (message.lastErrorReason !== "") {
      obj.lastErrorReason = message.lastErrorReason;
    }
    return obj;
  },

  create(base?: DeepPartial<ProbeResult>): ProbeResult {
    return ProbeResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProbeResult>): ProbeResult {
    const message = createBaseProbeResult();
    message.alive = object.alive ?? false;
    message.delay = object.delay ?? 0;
    message.lastErrorReason = object.lastErrorReason ?? "";
    return message;
  },
};

messageTypeRegistry.set(ProbeResult.$type, ProbeResult);

function createBaseIntensity(): Intensity {
  return { $type: "xray.core.app.observatory.Intensity", probeInterval: 0 };
}

export const Intensity: MessageFns<Intensity, "xray.core.app.observatory.Intensity"> = {
  $type: "xray.core.app.observatory.Intensity" as const,

  encode(message: Intensity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.probeInterval !== 0) {
      writer.uint32(8).uint32(message.probeInterval);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Intensity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntensity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.probeInterval = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Intensity {
    return {
      $type: Intensity.$type,
      probeInterval: isSet(object.probeInterval) ? globalThis.Number(object.probeInterval) : 0,
    };
  },

  toJSON(message: Intensity): unknown {
    const obj: any = {};
    if (message.probeInterval !== 0) {
      obj.probeInterval = Math.round(message.probeInterval);
    }
    return obj;
  },

  create(base?: DeepPartial<Intensity>): Intensity {
    return Intensity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Intensity>): Intensity {
    const message = createBaseIntensity();
    message.probeInterval = object.probeInterval ?? 0;
    return message;
  },
};

messageTypeRegistry.set(Intensity.$type, Intensity);

function createBaseConfig(): Config {
  return {
    $type: "xray.core.app.observatory.Config",
    subjectSelector: [],
    probeUrl: "",
    probeInterval: 0,
    enableConcurrency: false,
  };
}

export const Config: MessageFns<Config, "xray.core.app.observatory.Config"> = {
  $type: "xray.core.app.observatory.Config" as const,

  encode(message: Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subjectSelector) {
      writer.uint32(18).string(v!);
    }
    if (message.probeUrl !== "") {
      writer.uint32(26).string(message.probeUrl);
    }
    if (message.probeInterval !== 0) {
      writer.uint32(32).int64(message.probeInterval);
    }
    if (message.enableConcurrency !== false) {
      writer.uint32(40).bool(message.enableConcurrency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subjectSelector.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.probeUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.probeInterval = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.enableConcurrency = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Config {
    return {
      $type: Config.$type,
      subjectSelector: globalThis.Array.isArray(object?.subjectSelector)
        ? object.subjectSelector.map((e: any) => globalThis.String(e))
        : [],
      probeUrl: isSet(object.probeUrl) ? globalThis.String(object.probeUrl) : "",
      probeInterval: isSet(object.probeInterval) ? globalThis.Number(object.probeInterval) : 0,
      enableConcurrency: isSet(object.enableConcurrency) ? globalThis.Boolean(object.enableConcurrency) : false,
    };
  },

  toJSON(message: Config): unknown {
    const obj: any = {};
    if (message.subjectSelector?.length) {
      obj.subjectSelector = message.subjectSelector;
    }
    if (message.probeUrl !== "") {
      obj.probeUrl = message.probeUrl;
    }
    if (message.probeInterval !== 0) {
      obj.probeInterval = Math.round(message.probeInterval);
    }
    if (message.enableConcurrency !== false) {
      obj.enableConcurrency = message.enableConcurrency;
    }
    return obj;
  },

  create(base?: DeepPartial<Config>): Config {
    return Config.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Config>): Config {
    const message = createBaseConfig();
    message.subjectSelector = object.subjectSelector?.map((e) => e) || [];
    message.probeUrl = object.probeUrl ?? "";
    message.probeInterval = object.probeInterval ?? 0;
    message.enableConcurrency = object.enableConcurrency ?? false;
    return message;
  },
};

messageTypeRegistry.set(Config.$type, Config);

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
